\documentclass{beamer}
\usetheme{Pittsburgh}
\usecolortheme{spruce}

% for themes, etc.
\mode<presentation>
{ \usetheme{boxes} }

\usepackage{times}  % fonts are up to you
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\renewcommand{\algorithmicrequire}{\alert{Input:}}
\renewcommand{\algorithmicensure}{\alert{Output:}}

\setbeamertemplate{footline}[frame number]

% these will be used later in the title page
\title{Modular Multiplication}
\author{ Lucas Zewen Ye \\ lucas.zw.ye@outlook.com }
\date{September 15, 2021}

\AtBeginSection[]
{
\begin{frame}<beamer> 
\frametitle{Outline} % make a frame titled "Outline"
\setcounter{page}{0}	%setcounter似乎对beamer无效
\tableofcontents[currentsection]  % show TOC and highlight current section
\end{frame}
}


\begin{document}
% this prints title, author etc. info from above
\maketitle

\section{Finite Field}
\begin{frame}{Finite Field}
A finite field is a finite set that multiplication, addition, subtraction and division (excluding division by zero) are defined and satisfy the rules of arithmetic.

Given a \alert{prime} $p$, the finite field $GF(p)$ is made up of $0, 1, 2, ..., p-1$ (totally $p$ numbers).

\end{frame}

\section{Modular Operations}
\begin{frame}{Modular Reduction}
For any integer $a$, it can be written as:

$a = kp + r$ ($k,p,r$ are all integer, $r < p$ and $k \geq 0$)

so, $a \bmod p = r$

\hspace*{\fill}

Example: 

$20 \bmod 7$, $20 = 2 * 7 + 6$, so $20 \bmod 7 = 6$

$72 \bmod 13$, $72 = 5 * 13 + 7$, so $72 \bmod 13 = 7$

\end{frame}

\begin{frame}{Operations in Finite Field}
For any $a, b \in GF(p)$, 

Addition: $(a + b) \bmod p$

Subtraction: $(a - b) \bmod p$

Multiplication: $(a  b) \bmod p$

Inversion: $(inv(a) \cdot a) \bmod p = 1$

Division: $a / b = (a \cdot inv(b)) \bmod p$
\end{frame}

\begin{frame}{Operations in Finite Field}
Example: for $p=13, a=7, b=4$

$a + b = 11$

$a - b = (7 - 4) \bmod 13 = 3$

$a * b = 7 * 4 \bmod 13 = 2$

$inv(b) = 10$

$a / b = 7 * 10 \bmod 13 = 5$
\end{frame}

\begin{frame}{Properties of Modular Operations}	
$(a + b) \bmod p = (a \bmod p + b \bmod p) \bmod p$

$(a - b) \bmod p = (a \bmod p - b \bmod p) \bmod p$

$(a  b) \bmod p = (a \bmod p)   (b \bmod p) \bmod p$

$((a + b) \bmod p + c) \bmod p = (a + (b + c) \bmod p) \bmod p$

	$((a  b) \bmod p)  c \bmod p = (a  (b  c \bmod p)) \bmod p$

	$((a +b) \bmod p \cdot c) \bmod p = ((a  c) \bmod p + (b  c) \bmod p) \bmod p $
\end{frame}

\begin{frame}{Properties of Modular Operations}	
	\alert{Congruences}

	if $a \equiv b \pmod p$, then for any $c, (a + c) \equiv (b + c) \pmod p$
	
	if $a \equiv b \pmod p$, then for any $c, (a  c) \equiv (b  c) \pmod p$
	
	if $a \equiv b \pmod p$ and $c \equiv d \pmod p$, then  
		\begin{itemize}
			\item	$(a + c) \equiv (b + d) \pmod p$
			\item	$(a - c) \equiv (b - d) \pmod p$
			\item   $(a  c) \equiv (b  d) \pmod p$
			\item   $(a / c) \equiv (b / d) \pmod p$
		\end{itemize}
	
		\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
0  & 1  & 2  & 3  & 4  \\ \hline
5  & 6  & 7  & 8  & 9  \\ \hline
10 & 11 & 12 & 13 & 14 \\ \hline
15 & 16 & 17 & 18 & 19 \\ \hline
\end{tabular}
\end{table}
\end{frame}

\section{Modular Algorithms}
\begin{frame}{Basic Modular Reduction}
% 用减法表示除法
$a = kp + r$ ($k,p,r$ are all integer, $r < p$ and $k \geq 0$)

	Use many \alert{subtractions} of $p$ to realize the modular reduction

	\hspace*{\fill}

	$a \bmod p = a - p - ... - p$ until the subtraction result is smaller than p
% 强调除法在硬件实现中的难度。（SRT）
\end{frame}

% 听众仅理解了r需要通过除法（减法）得到
\begin{frame}{Barrett Modular Multiplication}

% 首先讲这个算法的核心：
% m/2^k = 1/p -- 把除法变成移位:
% 除一个数等于乘一个数再移位，为什么要移k位：原因是k位乘k位最后会成为2k位，因此需要移k位，这就是2^k的来历
% 因此假设 m = 2^k/p
% a/p = (a * m << k)
% 1. 把q1 -> q2 -> q3 为什么要分三步解释清楚为了弥补取下整的问题
% 区分2k和k

General idea:Let $s = 1/p$, $a \bmod p = a - \lfloor as \rfloor p$

Assume $\frac{m}{2^k} = \frac{1}{p}$, we can use $\frac{m}{2^k}$ to replace $\frac{1}{p}$, here $m = \frac{2^k}{p}$
	%\includegraphics[width=1.0\textwidth]{fig/barrett.png}
	\begin{algorithmic}
		\REQUIRE{$x = (x_{k-1}...x_1x_0)_2$,
			$y = (y_{k-1}...y_1y_0)_2$,
			$p = (p_{k-1}...p_1p_0)_2$,
			$m = \lfloor 2^{2k}/p\rfloor$}
		\ENSURE{$r=xy \ mod \ p$}
	
		\STATE $z \leftarrow x \cdot y$
	
		\STATE $q_1 \leftarrow z >> (k-1)$
	
		\STATE $q_2 \leftarrow q_1 \cdot m$
	
		\STATE $q_3 \leftarrow q_2 >> (k+1)$
	
		\STATE $r \leftarrow z - q_3 \cdot p$
	
		\IF{$r >= 2p$}
			\STATE $r \leftarrow r - 2p$ 
		\ELSIF{$r >= p$}
			\STATE$r \leftarrow r - p$
		\ENDIF
		\RETURN{$r$}
\end{algorithmic}
\end{frame}

% 首先强调前一种算法的问题：问题在大数乘法的硬件开销：
% 需要介绍乘法的硬件实现（一堆CSA加起来）
% montgomery使用了迭代的思路：减少了乘法的开销
% 
% 把你的pdf的关键例子写成latex：
% 模乘只需要k位，因此不需要低k位对高k位的影响
% 每一轮otf地去掉低k位对高k位的影响
% 再正向推导
\begin{frame}{Montgomery Modular Multiplication: Multiprecision Case}
	\begin{algorithmic}
		\REQUIRE{integers $N = (N_{n-1}...N_1N_0)_b$,
		$A = (A_{n-1}...A_1A_0)_b$,
		$B = (B_{n-1}...B_1B_0)_b$ with $0 \leq A, B < N$,
		$R = b^n=(10...0)_b$ with $gcd(N, b) = 1$,
		and $N' = -N^{-1} \bmod b$}
		\ENSURE{$ABR^{-1} \bmod N$}

		\STATE $T \gets 0$

		\FOR{$i \gets 0$ step $1$ to $n-1$}
		\STATE $u_i \gets (T_0 + A_iB_0)N' \bmod b$
		\STATE $T \gets (T+A_iB+u_iN)/b$
		\ENDFOR
		\IF {$T \geq N$}
		\RETURN $T-N$
		\ELSE
		\RETURN $T$
		\ENDIF
	\end{algorithmic}
\end{frame}


\begin{frame}{Montgomery Modular Multiplication}
$R = b^{\lceil \log_b N \rceil},  gcd(N,R)=1$

$RR^{-1} \bmod N = 1, RR^{-1} - NN' = 1$

\hspace*{\fill}

	$Mont(A,B) = A \cdot B \cdot R^{-1} \bmod N$

	\begin{itemize}
	\item $T = A \cdot B$
	\item $m =  T \cdot N' \bmod R$ 
    \item $t = (T + N\cdot m)/R$
    \item $if \ t>N \ return \ (t-N)\  else \  return \ t$
\end{itemize}
\end{frame}

\begin{frame}{Montgomery Modular Multiplication}
Prof: Assume $k$ is an integer, and $k < 0$, $m = TN'+kR < R$ 
	\begin{equation}\nonumber
		\begin{aligned}
		t &= (T + N\cdot m)/R \\
		&= (T + N\cdot(TN'+kR)) / R \\
		&= (T + TNN' + kRN)/R \\
		&= (T(1+NN')+kRN)/R\\
		&= TR' + kN \\
		&= A \cdot B \cdot R^{-1} + kN
\end{aligned}
	\end{equation}
\end{frame}


\begin{frame}{}
  \centering \Large
	\emph{Thanks}
\end{frame}

\end{document}
